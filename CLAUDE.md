# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Crypto Map Pay App Widget is a Nuxt 4 application that helps users discover crypto-friendly locations in Lugano. It uses PostgreSQL with PostGIS for geospatial queries, deployed on NuxtHub/Cloudflare, and styled with UnoCSS using the Nimiq design system.

## Development Commands

```bash
# Development
pnpm run dev              # Start dev server on localhost:3000
pnpm run build            # Build for production
pnpm run preview          # Preview production build

# Database (uses Supabase remote)
pnpm run db:setup         # Run migrations and seeds on remote Supabase
pnpm run db:generate      # Generate Drizzle migrations from schema changes
pnpm run db:push          # Push migrations to remote Supabase via CLI

# Code Quality
pnpm run lint             # Run ESLint with cache
pnpm run lint:fix         # Auto-fix ESLint issues
pnpm run typecheck        # Run TypeScript type checking
```

## Architecture

### Database Architecture

The app uses **PostgreSQL with PostGIS** and a normalized relational schema with three tables:

1. **`categories`** - Stores all unique Google Maps category types (e.g., "cafe", "restaurant", "bank")
   - Extracted dynamically from location data
   - Uses category ID as primary key (e.g., "food", "lodging")
   - Schema: `id` (text), `name` (text), `createdAt` (timestamp)

2. **`locations`** - Main location data with PostGIS geometry
   - Primary key: auto-generated UUID
   - **Uses PostGIS `geometry(point, 4326)` for location** instead of separate lat/lng columns
   - GIST spatial index on `location` column for efficient proximity queries
   - Schema: `uuid`, `name`, `address`, `location` (geometry point), `rating`, `photo`, `gmapsPlaceId`, `gmapsUrl`, `website`, `source`, `createdAt`, `updatedAt`
   - Extract coordinates using `ST_X(location)` for longitude and `ST_Y(location)` for latitude

3. **`location_categories`** - Junction table for many-to-many relationship
   - Links locations to categories via foreign keys
   - Composite primary key on (locationUuid, categoryId)
   - Indexed on both foreign keys

**Important**: When adding locations:

1. Insert into `locations` table with location as `{x: longitude, y: latitude}`
2. Insert corresponding rows into `location_categories` junction table
3. PostGIS automatically handles the geometry conversion

### Database Setup and Seeding

The project uses **Supabase** for remote database management:

- **Remote**: Connected to Supabase project (wwiwmsgedqeepcdtnhon) via connection pooler
- Migrations are stored in `database/migrations/` (generated by Drizzle)
- Seed files are stored in `database/seeds/`:
  - `rls-policies.sql` - Row Level Security policies
  - `categories.sql` - All Google Maps category types with icon mappings
  - `sources/*.sql` - Location data from various sources

**Database workflow**:

1. Generate migrations from schema changes: `pnpm run db:generate`
2. Apply migrations and seeds to remote: `pnpm run db:setup`
3. (Optional) Push via Supabase CLI: `pnpm run db:push`

The `db:setup` script (`scripts/db-setup.ts`):

- Enables PostGIS extension automatically
- Runs all migrations in order, tracking applied migrations to avoid duplicates
- Applies RLS policies and seeds data from SQL files
- Uses connection pooler with `prepare: false` for transaction pooling mode

### API Endpoints

**`GET /api/categories`**

- Returns all categories from the database
- Used to populate filter UI
- Categories are dynamically extracted from location data

**`GET /api/search`**

- Query params: `q` (search query, optional), `lat`/`lng` (optional)
- If lat/lng not provided, attempts Cloudflare IP geolocation via `locateByHost()`
- **Location data is available but NOT used for sorting yet** - just logged to console
- Returns 10 random locations if no search query provided
- Filters by location name using `LIKE` when search query is provided
- Uses PostgreSQL `STRING_AGG()` to aggregate categories
- Extracts lat/lng from PostGIS geometry using `ST_Y()` and `ST_X()`

### Styling System

The app uses **UnoCSS with Nimiq presets**:

- `presetOnmax()` - Base utilities
- `presetNimiq()` - Nimiq design system utilities and attributify mode
- Utilities are applied via **attributify syntax** directly on elements (e.g., `flex="~ col gap-16"`)
- Nimiq CSS provides the `f-` prefix utilities for consistent spacing/typography
- Custom utility examples: `f-mb-lg`, `f-py-xl`, `f-px-md`, `text="neutral-900 f-lg"`

### UI Components

- **Reka UI** is used for accessible components (Vue port of Radix UI)
- Auto-imported via `reka-ui/nuxt` module in nuxt.config.ts
- Example: `ToggleGroupRoot` + `ToggleGroupItem` for category filters
- Must use the `Root` component (e.g., `ToggleGroupRoot`, not `ToggleGroup`)

### Type Safety

- **Valibot** is used for runtime validation (not Zod)
- Query parameters are validated in API routes using `v.safeParse()`
- Example pattern: `v.pipe(v.string(), v.transform(Number), v.number())`
- Runtime config validation via `nuxt-safe-runtime-config` with Valibot schema

### Database Access

- Use `useDrizzle()` helper to get database instance
- Import schema as `tables` from `server/utils/drizzle.ts`
- Schema is defined in `database/schema.ts`
- Type exports: `Location`, `Category`, `LocationCategory`
- Connection uses `DATABASE_URL` environment variable
- Must use `prepare: false` option for Supabase transaction pooler
- PostgreSQL-specific: Use `sql` tagged templates for PostGIS queries
- PostGIS functions: `ST_X()`, `ST_Y()`, `ST_Distance()`, `ST_Within()`, etc.

## Key Patterns

### Adding New Locations

1. Add location data to `database/seeds/sources/dummy.sql` or create a new source SQL file
2. Categories must be valid Google Maps types (snake_case strings) from `database/seeds/categories.sql`
3. Use PostGIS `ST_SetSRID(ST_MakePoint(longitude, latitude), 4326)` for location geometry
4. Insert corresponding rows into `location_categories` junction table
5. Apply changes: `pnpm run db:setup` (runs migrations and seeds)

### Category Filtering

- Categories use raw Google Maps types (e.g., "restaurant", "cafe", "lodging")
- The old `CATEGORY_MAPPING` system was removed - now using direct Google types
- UI displays formatted category names (underscores â†’ spaces, title case)
- Backend stores raw snake_case IDs

### Geolocation

- Cloudflare provides `cf-connecting-ip` header in production
- Dev environment requires manual lat/lng query params
- Currently location is retrieved but NOT used for distance sorting

## Configuration Files

- **`nuxt.config.ts`** - Nuxt config with NuxtHub, UnoCSS, Reka UI modules, PostgreSQL runtime config
- **`drizzle.config.ts`** - PostgreSQL dialect, schema at `database/schema.ts`, migrations output to `database/migrations/`
- **`uno.config.ts`** - UnoCSS with Nimiq presets
- **`eslint.config.mjs`** - Antfu's ESLint config with Nuxt integration
- **`supabase/config.toml`** - Supabase local development configuration
- **`scripts/db-setup.ts`** - Unified migration and seeding script
- **`database/migrations/`** - Drizzle-generated SQL migrations
- **`database/seeds/rls-policies.sql`** - Row Level Security policies
- **`database/seeds/categories.sql`** - All Google Maps categories with icons
- **`database/seeds/sources/*.sql`** - Location data from various sources

## Environment Variables

Required in `.env` (project root):

```env
# PostgreSQL Configuration (Supabase Remote)
DATABASE_URL=postgresql://postgres.wwiwmsgedqeepcdtnhon:[YOUR-PASSWORD]@aws-1-eu-central-1.pooler.supabase.com:6543/postgres

# API Keys
NUXT_GOOGLE_API_KEY=your_api_key
```

**Important**:

- Uses Supabase connection pooler (port 6543) for remote database access
- The pooler provides IPv4 connectivity (required for some WSL/network setups)
- Connection uses transaction pooling mode (requires `prepare: false` in postgres client)
- All variables are validated via `safeRuntimeConfig` using Valibot schema

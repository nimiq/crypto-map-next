# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Crypto Map Pay App Widget is a Nuxt 4 application that helps users discover crypto-friendly locations in Lugano. It uses PostgreSQL with PostGIS for geospatial queries and pgvector for semantic search via OpenAI embeddings. The app features hybrid search combining PostgreSQL full-text search with AI-powered category matching. Deployed on NuxtHub/Cloudflare and styled with UnoCSS using the Nimiq design system.

## Development Commands

```bash
# Development
pnpm run dev              # Start dev server on localhost:3000
pnpm run build            # Build for production
pnpm run preview          # Preview production build

# Database (requires .env file in project root)
pnpm run db:start         # Start PostgreSQL + PostGIS with Docker
pnpm run db:stop          # Stop database
pnpm run db:restart       # Restart database (useful for reseeding)
pnpm run db:generate      # Generate Drizzle migrations from schema changes

# Code Quality
pnpm run lint             # Run ESLint with cache
pnpm run lint:fix         # Auto-fix ESLint issues
pnpm run typecheck        # Run TypeScript type checking
```

## Architecture

### Database Architecture

The app uses **PostgreSQL with PostGIS and pgvector** and a normalized relational schema with three tables:

1. **`categories`** - Stores all unique Google Maps category types with vector embeddings
   - Schema: `id` (text, PK), `name` (text), `icon` (text), `embedding` (vector(1536)), `createdAt` (timestamp)
   - **Vector embeddings** enable semantic search - "coffee shop" matches "cafe" without exact text match
   - Embeddings are generated via OpenAI text-embedding-3-small (1536 dimensions)
   - Categories are seeded from `database/seeds/categories.sql`

2. **`locations`** - Main location data with PostGIS geometry and opening hours
   - Primary key: auto-generated UUID
   - **Uses PostGIS `geometry(point, 4326)` for location** instead of separate lat/lng columns
   - GIST spatial index on `location` column for efficient proximity queries
   - Schema: `uuid`, `name`, `address`, `location` (geometry point), `rating`, `photo`, `gmapsPlaceId` (unique), `gmapsUrl`, `website`, `source`, `timezone`, `openingHours`, `createdAt`, `updatedAt`
   - `timezone`: IANA timezone identifier (e.g., "Europe/Zurich")
   - `openingHours`: JSON string with weekly opening hours
   - Extract coordinates using `ST_X(location)` for longitude and `ST_Y(location)` for latitude

3. **`location_categories`** - Junction table for many-to-many relationship
   - Links locations to categories via foreign keys with cascade delete
   - Composite primary key on (locationUuid, categoryId)
   - Indexed on both foreign keys for efficient joins

**Important**: When adding locations:

1. Insert into `locations` table with location as `{x: longitude, y: latitude}`
2. Insert corresponding rows into `location_categories` junction table
3. PostGIS automatically handles the geometry conversion

### Database Seeding

- **Automatic seeding** via Docker Compose when starting the PostgreSQL database
- Migrations are stored in `database/migrations/` (generated by Drizzle)
- Seed files are stored in `database/seeds/`:
  - `categories.sql` - All Google Maps category types with icon mappings and vector embeddings
  - `sources/dummy.sql` - Dummy location data for testing
- The seeding process (executed by Docker):
  1. `init.sh` - Creates PostGIS and pgvector extensions, roles, and permissions
  2. `run-migrations.sh` - Applies Drizzle migrations to create tables
  3. `rls-policies.sql` - Applies Row Level Security policies
  4. Seeds categories with embeddings and dummy location data
- To start/restart database: `pnpm run db:start`
- To regenerate migrations after schema changes: `pnpm run db:generate`

### Search System

The app implements **hybrid search** combining two approaches:

1. **Text Search** - PostgreSQL Full-Text Search (FTS)
   - Uses `to_tsvector` and `to_tsquery` for fast text matching
   - Searches across location name and address fields
   - `ts_headline` generates highlighted snippets with `<mark>` tags
   - Used in autocomplete for instant results (10-50ms)

2. **Semantic Search** - Vector similarity via pgvector
   - Query → OpenAI embedding → Find similar category embeddings
   - Uses cosine similarity with threshold 0.7 (configurable in `server/utils/search.ts`)
   - Returns top 5 matching categories
   - Then fetches locations belonging to those categories

3. **Embedding Cache** - NuxtHub KV
   - Permanent cache (no TTL) for query embeddings
   - Reduces OpenAI API costs and latency
   - Autocomplete precomputes embeddings in background
   - Cache key: `embedding:${query.trim().toLowerCase()}`

### API Endpoints

**`GET /api/categories`**

- Returns all categories from the database
- Used to populate filter UI
- Categories are dynamically extracted from location data

**`GET /api/search`**

- Query params: `q` (search query, optional), `lat`/`lng` (optional)
- If lat/lng not provided, attempts Cloudflare IP geolocation via `locateByHost()`
- **Location data is available but NOT used for sorting yet** - just logged to console
- Returns 10 random locations if no search query provided
- Filters by location name using `LIKE` when search query is provided
- Uses PostgreSQL `STRING_AGG()` to aggregate categories
- Extracts lat/lng from PostGIS geometry using `ST_Y()` and `ST_X()`

### Styling System

The app uses **UnoCSS with Nimiq presets**:

- `presetOnmax()` - Base utilities
- `presetNimiq()` - Nimiq design system utilities and attributify mode
- Utilities are applied via **attributify syntax** directly on elements (e.g., `flex="~ col gap-16"`)
- Nimiq CSS provides the `f-` prefix utilities for consistent spacing/typography
- Custom utility examples: `f-mb-lg`, `f-py-xl`, `f-px-md`, `text="neutral-900 f-lg"`

### UI Components

- **Reka UI** is used for accessible components (Vue port of Radix UI)
- Auto-imported via `reka-ui/nuxt` module in nuxt.config.ts
- Example: `ToggleGroupRoot` + `ToggleGroupItem` for category filters
- Must use the `Root` component (e.g., `ToggleGroupRoot`, not `ToggleGroup`)

### Type Safety

- **Valibot** is used for runtime validation (not Zod)
- Query parameters are validated in API routes using `v.safeParse()`
- Example pattern: `v.pipe(v.string(), v.transform(Number), v.number())`
- Runtime config validation via `nuxt-safe-runtime-config` with Valibot schema

### Database Access

- Use `useDrizzle()` helper to get database instance
- Import schema as `tables` from `server/utils/drizzle.ts`
- Schema is defined in `database/schema.ts`
- Type exports: `Location`, `Category`, `LocationCategory`
- Connection uses individual env vars (POSTGRES_HOST, POSTGRES_PORT, POSTGRES_USER, POSTGRES_PASSWORD, POSTGRES_DB)
- PostgreSQL-specific: Use `sql` tagged templates for PostGIS queries
- PostGIS functions: `ST_X()`, `ST_Y()`, `ST_Distance()`, `ST_Within()`, etc.

## Key Patterns

### Adding New Locations

1. Add location data to `database/seeds/sources/dummy.sql` or create a new source SQL file
2. Categories must be valid Google Maps types (snake_case strings) from `database/seeds/categories.sql`
3. Use PostGIS `ST_SetSRID(ST_MakePoint(longitude, latitude), 4326)` for location geometry
4. Insert corresponding rows into `location_categories` junction table
5. Restart Docker Compose to apply changes: `pnpm run db:restart`

### Category Filtering

- Categories use raw Google Maps types (e.g., "restaurant", "cafe", "lodging")
- The old `CATEGORY_MAPPING` system was removed - now using direct Google types
- UI displays formatted category names (underscores → spaces, title case)
- Backend stores raw snake_case IDs

### Geolocation

- Cloudflare provides `cf-connecting-ip` header in production
- Dev environment requires manual lat/lng query params
- Currently location is retrieved but NOT used for distance sorting

## Configuration Files

- **`nuxt.config.ts`** - Nuxt config with NuxtHub, UnoCSS, Reka UI modules, PostgreSQL runtime config
- **`drizzle.config.ts`** - PostgreSQL dialect, schema at `database/schema.ts`, migrations output to `database/migrations/`
- **`uno.config.ts`** - UnoCSS with Nimiq presets
- **`eslint.config.mjs`** - Antfu's ESLint config with Nuxt integration
- **`database/docker-compose.yml`** - Docker Compose setup for local PostgreSQL development
- **`database/init.sh`** - Initializes PostGIS extensions and permissions
- **`database/run-migrations.sh`** - Runs Drizzle migrations on container start
- **`database/rls-policies.sql`** - Row Level Security policies
- **`database/seeds/categories.sql`** - All Google Maps categories with icons
- **`database/seeds/sources/dummy.sql`** - Dummy location data

## Environment Variables

Required in `.env` (project root):

```env
# PostgreSQL Configuration
POSTGRES_HOST=localhost
POSTGRES_PORT=5432
POSTGRES_USER=postgres
POSTGRES_PASSWORD=your_password
POSTGRES_DB=postgres

# API Keys
NUXT_GOOGLE_API_KEY=your_api_key
```

All variables are validated via `safeRuntimeConfig` using Valibot schema.
